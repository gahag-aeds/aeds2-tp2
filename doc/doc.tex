\documentclass{article}

\usepackage[margin=1in]{geometry}

\usepackage{graphicx}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}


\setlength{\parskip}{5pt}%
\setlength\parindent{0pt}


\begin{document}

\begin{titlepage}
  \centering
  
  \vfill{
    \bfseries\Huge
    Universidade Federal de Minas Gerais\\[5pt]
    \bfseries\Large
    Bacharel em Sistemas de Informação \\
    Algoritmos e Estruturas de Dados 2\\
  }
  
  \vfill
  
  \includegraphics[width=13cm]{images/ufmg_logo.jpg}
  
  \vfill{
    \bfseries\Large
    Trabalho Prático 2\\
    Junho 2017\\
  }
  \vfill{
    \bfseries\large
    Gabriel Silva Bastos\\[5pt]
    Matrícula: 2016058204
  }
\end{titlepage}


\section{Introdução}
O trabalho prático consiste em ordenar um vetor de números naturais que representam as colunas na caixa mágica de Fernanda.

O tamanho do vetor está entre 1 e 100000 elementos. A faixa de distribuição dos elementos do vetor é de 1 a 100.


\section{Visão geral da solução}
Devido à grande quantidade máxima de colunas, um vetor dinamicamente alocado foi utilizado para armazenar os dados.

Devido à curta faixa de distruibuição dos dados, o algoritmo \textit{counting sort} foi escolhido para a solução.


\section{Estrutura do projeto}
A organização dos diretórios no projeto foi definida da seguinte forma:

\begin{tabular}{ll}
  bin:& binários resultantes da compilação.\\
  tests:& dados e ferramentas de teste.\\
  doc:& arquivos referentes à documentação do projeto.\\
  src:& código fonte da solução.
\end{tabular}

Adicionalmente, um \textit{makefile} foi desenvolvido para compilar o projeto. Como requerido, um \textit{script} denominado \textit{compile.sh} foi implementado para executar o \textit{makefile}.


\section{Análise de complexidade}
O algoritmo \textit{counting sort} apresenta complexidade $\mathcal{O}(k + n)$, onde $k$ é a largura da faixa de distribuição dos elementos e $n$ é a quantidade de elementos.
Sendo $k = 100$, a complexidade final obtida é $\mathcal{O}(n + 100) = \mathcal{O}(n)$.

A documentação específica sobre o cálculo de complexidade referente a cada função foi incluída como comentários adjacentes ao código correspondente.


\section{Conclusão}
A complexidade final obtida $\mathcal{O}(n)$ é a melhor possível para a classe de ordenação, sendo inclusive melhor que a de qualquer algoritmo de ordenação por comparação ótimo $\mathcal{O}(n \log n)$.


\end{document}
